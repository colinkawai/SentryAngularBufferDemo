import { Directive, Injectable, Input, NgModule } from '@angular/core';
// Duplicated import to work around a TypeScript bug where it'd complain that `Router` isn't imported as a type.
// We need to import it as a value to satisfy Angular dependency injection. So:
// eslint-disable-next-line @typescript-eslint/consistent-type-imports
import { NavigationCancel, NavigationError } from '@angular/router';
import { NavigationEnd, NavigationStart, ResolveEnd } from '@angular/router';
import { browserTracingIntegration as originalBrowserTracingIntegration, getActiveSpan, getClient, getCurrentScope, getRootSpan, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, spanToJSON, startBrowserTracingNavigationSpan, startInactiveSpan, } from '@sentry/browser';
import { debug, stripUrlQueryAndFragment, timestampInSeconds } from '@sentry/core';
import { Subscription } from 'rxjs';
import { filter, tap } from 'rxjs/operators';
import { ANGULAR_INIT_OP, ANGULAR_OP, ANGULAR_ROUTING_OP } from './constants';
import { IS_DEBUG_BUILD } from './flags';
import { runOutsideAngular } from './zone';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
let instrumentationInitialized;
/**
 * A custom browser tracing integration for Angular.
 *
 * Use this integration in combination with `TraceService`
 */
export function browserTracingIntegration(options = {}) {
    // If the user opts out to set this up, we just don't initialize this.
    // That way, the TraceService will not actually do anything, functionally disabling this.
    if (options.instrumentNavigation !== false) {
        instrumentationInitialized = true;
    }
    return originalBrowserTracingIntegration({
        ...options,
        instrumentNavigation: false,
    });
}
/**
 * This function is extracted to make unit testing easier.
 */
export function _updateSpanAttributesForParametrizedUrl(route, span) {
    const attributes = (span && spanToJSON(span).data) || {};
    if (span && attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'url') {
        span.updateName(route);
        span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'route');
        span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, `auto.${spanToJSON(span).op}.angular`);
    }
}
/**
 * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
 * Creates a new transaction for every route change and measures a duration of routing process.
 */
export class TraceService {
    constructor(_router) {
        this._router = _router;
        this.navStart$ = this._router.events.pipe(filter((event) => event instanceof NavigationStart), tap(navigationEvent => {
            if (!instrumentationInitialized) {
                IS_DEBUG_BUILD &&
                    debug.error('Angular integration has tracing enabled, but Tracing integration is not configured');
                return;
            }
            if (this._routingSpan) {
                this._routingSpan.end();
                this._routingSpan = null;
            }
            const client = getClient();
            const strippedUrl = stripUrlQueryAndFragment(navigationEvent.url);
            if (client) {
                // see comment in `_isPageloadOngoing` for rationale
                if (!this._isPageloadOngoing()) {
                    runOutsideAngular(() => {
                        startBrowserTracingNavigationSpan(client, {
                            name: strippedUrl,
                            attributes: {
                                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.angular',
                                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                            },
                        });
                    });
                }
                else {
                    // The first time we end up here, we set the pageload flag to false
                    // Subsequent navigations are going to get their own navigation root span
                    // even if the pageload root span is still ongoing.
                    this._pageloadOngoing = false;
                }
                this._routingSpan =
                    runOutsideAngular(() => startInactiveSpan({
                        name: `${navigationEvent.url}`,
                        op: ANGULAR_ROUTING_OP,
                        attributes: {
                            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular',
                            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                            url: strippedUrl,
                            ...(navigationEvent.navigationTrigger && {
                                navigationTrigger: navigationEvent.navigationTrigger,
                            }),
                        },
                    })) || null;
                return;
            }
        }));
        // The ResolveEnd event is fired when the Angular router has resolved the URL and
        // the parameter<->value mapping. It holds the new resolved router state with
        // the mapping and the new URL.
        // Only After this event, the route is activated, meaning that the transaction
        // can be updated with the parameterized route name before e.g. the route's root
        // component is initialized. This should be early enough before outgoing requests
        // are made from the new route, with the exceptions of requests being made during
        // a navigation.
        this.resEnd$ = this._router.events.pipe(filter((event) => event instanceof ResolveEnd), tap(event => {
            const route = getParameterizedRouteFromSnapshot(event.state.root);
            if (route) {
                getCurrentScope().setTransactionName(route);
            }
            const activeSpan = getActiveSpan();
            const rootSpan = activeSpan && getRootSpan(activeSpan);
            _updateSpanAttributesForParametrizedUrl(route, rootSpan);
        }));
        this.navEnd$ = this._router.events.pipe(filter(event => event instanceof NavigationEnd || event instanceof NavigationCancel || event instanceof NavigationError), tap(() => {
            if (this._routingSpan) {
                runOutsideAngular(() => {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this._routingSpan.end();
                });
                this._routingSpan = null;
            }
        }));
        this._routingSpan = null;
        this._pageloadOngoing = true;
        this._subscription = new Subscription();
        this._subscription.add(this.navStart$.subscribe());
        this._subscription.add(this.resEnd$.subscribe());
        this._subscription.add(this.navEnd$.subscribe());
    }
    /**
     * This is used to prevent memory leaks when the root view is created and destroyed multiple times,
     * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.
     */
    ngOnDestroy() {
        this._subscription.unsubscribe();
    }
    /**
     * We only _avoid_ creating a navigation root span in one case:
     *
     * There is an ongoing pageload span AND the router didn't yet emit the first navigation start event
     *
     * The first navigation start event will create the child routing span
     * and update the pageload root span name on ResolveEnd.
     *
     * There's an edge case we need to avoid here: If the router fires the first navigation start event
     * _after_ the pageload root span finished. This is why we check for the pageload root span.
     * Possible real-world scenario: Angular application and/or router is bootstrapped after the pageload
     * idle root span finished
     *
     * The overall rationale is:
     * - if we already avoided creating a navigation root span once, we don't avoid it again
     *   (i.e. set `_pageloadOngoing` to `false`)
     * - if `_pageloadOngoing` is already `false`, create a navigation root span
     * - if there's no active/pageload root span, create a navigation root span
     * - only if there's an ongoing pageload root span AND `_pageloadOngoing` is still `true,
     *   don't create a navigation root span
     */
    _isPageloadOngoing() {
        if (!this._pageloadOngoing) {
            // pageload is already finished, no need to update
            return false;
        }
        const activeSpan = getActiveSpan();
        if (!activeSpan) {
            this._pageloadOngoing = false;
            return false;
        }
        const rootSpan = getRootSpan(activeSpan);
        this._pageloadOngoing = spanToJSON(rootSpan).op === 'pageload';
        return this._pageloadOngoing;
    }
}
TraceService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceService, deps: [{ token: i1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
TraceService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.Router }]; } });
/**
 * Captures the initialization lifecycle of the component this directive is applied to.
 * Specifically, this directive measures the time between `ngOnInit` and `ngAfterViewInit`
 * of the component.
 *
 * Falls back to the component's selector if no name is provided.
 *
 * @example
 * ```html
 * <app-my-component trace="myComponent"></app-my-component>
 * ```
 */
export class TraceDirective {
    constructor(_host) {
        this._host = _host;
    }
    /**
     * Implementation of OnInit lifecycle method
     * @inheritdoc
     */
    ngOnInit() {
        if (!this.componentName) {
            // Technically, the `trace` binding should always be provided.
            // However, if it is incorrectly declared on the element without a
            // value (e.g., `<app-component trace />`), we fall back to using `tagName`
            // (which is e.g. `APP-COMPONENT`).
            this.componentName = this._host.nativeElement.tagName.toLowerCase();
        }
        if (getActiveSpan()) {
            this._tracingSpan = runOutsideAngular(() => startInactiveSpan({
                name: `<${this.componentName}>`,
                op: ANGULAR_INIT_OP,
                attributes: { [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular.trace_directive' },
            }));
        }
    }
    /**
     * Implementation of AfterViewInit lifecycle method
     * @inheritdoc
     */
    ngAfterViewInit() {
        const span = this._tracingSpan;
        if (span) {
            runOutsideAngular(() => span.end());
        }
    }
}
TraceDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
TraceDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.3.0", type: TraceDirective, selector: "[trace]", inputs: { componentName: ["trace", "componentName"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[trace]' }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { componentName: [{
                type: Input,
                args: ['trace']
            }] } });
/**
 * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.
 */
export class TraceModule {
}
TraceModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TraceModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.3.0", ngImport: i0, type: TraceModule, declarations: [TraceDirective], exports: [TraceDirective] });
TraceModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TraceDirective],
                    exports: [TraceDirective],
                }]
        }] });
/**
 * Decorator function that can be used to capture initialization lifecycle of the whole component.
 */
export function TraceClass(options) {
    let tracingSpan;
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    return target => {
        const originalOnInit = target.prototype.ngOnInit;
        target.prototype.ngOnInit = function (...args) {
            tracingSpan = runOutsideAngular(() => startInactiveSpan({
                onlyIfParent: true,
                name: `<${options?.name || 'unnamed'}>`,
                op: ANGULAR_INIT_OP,
                attributes: {
                    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular.trace_class_decorator',
                },
            }));
            if (originalOnInit) {
                return originalOnInit.apply(this, args);
            }
        };
        const originalAfterViewInit = target.prototype.ngAfterViewInit;
        target.prototype.ngAfterViewInit = function (...args) {
            if (tracingSpan) {
                runOutsideAngular(() => tracingSpan.end());
            }
            if (originalAfterViewInit) {
                return originalAfterViewInit.apply(this, args);
            }
        };
    };
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}
/**
 * Decorator function that can be used to capture a single lifecycle methods of the component.
 */
export function TraceMethod(options) {
    return (_target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        descriptor.value = function (...args) {
            const now = timestampInSeconds();
            runOutsideAngular(() => {
                startInactiveSpan({
                    onlyIfParent: true,
                    name: `<${options?.name ? options.name : 'unnamed'}>`,
                    op: `${ANGULAR_OP}.${String(propertyKey)}`,
                    startTime: now,
                    attributes: {
                        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular.trace_method_decorator',
                    },
                }).end(now);
            });
            if (originalMethod) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                return originalMethod.apply(this, args);
            }
        };
        return descriptor;
    };
}
/**
 * Takes the parameterized route from a given ActivatedRouteSnapshot and concatenates the snapshot's
 * child route with its parent to produce the complete parameterized URL of the activated route.
 * This happens recursively until the last child (i.e. the end of the URL) is reached.
 *
 * @param route the ActivatedRouteSnapshot of which its path and its child's path is concatenated
 *
 * @returns the concatenated parameterized route string
 */
export function getParameterizedRouteFromSnapshot(route) {
    const parts = [];
    let currentRoute = route?.firstChild;
    while (currentRoute) {
        const path = currentRoute?.routeConfig && currentRoute.routeConfig.path;
        if (path === null || path === undefined) {
            break;
        }
        parts.push(path);
        currentRoute = currentRoute.firstChild;
    }
    const fullPath = parts.filter(part => part).join('/');
    return fullPath ? `/${fullPath}/` : '/';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2luZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFjaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFdkUsZ0hBQWdIO0FBQ2hILCtFQUErRTtBQUMvRSxzRUFBc0U7QUFDdEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGVBQWUsRUFBVSxNQUFNLGlCQUFpQixDQUFDO0FBQzVFLE9BQU8sRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzdFLE9BQU8sRUFDTCx5QkFBeUIsSUFBSSxpQ0FBaUMsRUFDOUQsYUFBYSxFQUNiLFNBQVMsRUFDVCxlQUFlLEVBQ2YsV0FBVyxFQUNYLGdDQUFnQyxFQUNoQyxnQ0FBZ0MsRUFDaEMsVUFBVSxFQUNWLGlDQUFpQyxFQUNqQyxpQkFBaUIsR0FDbEIsTUFBTSxpQkFBaUIsQ0FBQztBQUV6QixPQUFPLEVBQUUsS0FBSyxFQUFFLHdCQUF3QixFQUFFLGtCQUFrQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRW5GLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDcEMsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUM5RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFFBQVEsQ0FBQzs7O0FBRTNDLElBQUksMEJBQW1DLENBQUM7QUFFeEM7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSx5QkFBeUIsQ0FDdkMsVUFBbUUsRUFBRTtJQUVyRSxzRUFBc0U7SUFDdEUseUZB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UUFDRixPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLFVBQVUsaUNBQWlDLENBQUMsS0FBcUM7SUFDckYsTUFBTSxLQUFLLEdBQWEsRUFBRSxDQUFDO0lBRTNCLElBQUksWUFBWSxHQUFHLEtBQUssRUFBRSxVQUFVLENBQUM7SUFDckMsT0FBTyxZQUFZLEVBQUU7UUFDbkIsTUFBTSxJQUFJLEdBQUcsWUFBWSxFQUFFLFdBQVcsSUFBSSxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztRQUN4RSxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUN2QyxNQUFNO1NBQ1A7UUFFRCxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pCLFlBQVksR0FBRyxZQUFZLENBQUMsVUFBVSxDQUFDO0tBQ3hDO0lBRUQsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0RCxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1pbXBvcnRzXG5pbXBvcnQgeyBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEluamVjdGFibGUsIElucHV0LCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBFdmVudCwgUm91dGVyU3RhdGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuLy8gRHVwbGljYXRlZCBpbXBvcnQgdG8gd29yayBhcm91bmQgYSBUeXBlU2NyaXB0IGJ1ZyB3aGVyZSBpdCdkIGNvbXBsYWluIHRoYXQgYFJvdXRlcmAgaXNuJ3QgaW1wb3J0ZWQgYXMgYSB0eXBlLlxuLy8gV2UgbmVlZCB0byBpbXBvcnQgaXQgYXMgYSB2YWx1ZSB0byBzYXRpc2Z5IEFuZ3VsYXIgZGVwZW5kZW5jeSBpbmplY3Rpb24uIFNvOlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtaW1wb3J0c1xuaW1wb3J0IHsgTmF2aWdhdGlvbkNhbmNlbCwgTmF2aWdhdGlvbkVycm9yLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkVuZCwgTmF2aWdhdGlvblN0YXJ0LCBSZXNvbHZlRW5kIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7XG4gIGJyb3dzZXJUcmFjaW5nSW50ZWdyYXRpb24gYXMgb3JpZ2luYWxCcm93c2VyVHJhY2luZ0ludGVncmF0aW9uLFxuICBnZXRBY3RpdmVTcGFuLFxuICBnZXRDbGllbnQsXG4gIGdldEN1cnJlbnRTY29wZSxcbiAgZ2V0Um9vdFNwYW4sXG4gIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOLFxuICBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRSxcbiAgc3BhblRvSlNPTixcbiAgc3RhcnRCcm93c2VyVHJhY2luZ05hdmlnYXRpb25TcGFuLFxuICBzdGFydEluYWN0aXZlU3Bhbixcbn0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbmltcG9ydCB0eXBlIHsgSW50ZWdyYXRpb24sIFNwYW4gfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuaW1wb3J0IHsgZGVidWcsIHN0cmlwVXJsUXVlcnlBbmRGcmFnbWVudCwgdGltZXN0YW1wSW5TZWNvbmRzIH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB0eXBlIHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEFOR1VMQVJfSU5JVF9PUCwgQU5HVUxBUl9PUCwgQU5HVUxBUl9ST1VUSU5HX09QIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgSVNfREVCVUdfQlVJTEQgfSBmcm9tICcuL2ZsYWdzJztcbmltcG9ydCB7IHJ1bk91dHNpZGVBbmd1bGFyIH0gZnJvbSAnLi96b25lJztcblxubGV0IGluc3RydW1lbnRhdGlvbkluaXRpYWxpemVkOiBib29sZWFuO1xuXG4vKipcbiAqIEEgY3VzdG9tIGJyb3dzZXIgdHJhY2luZyBpbnRlZ3JhdGlvbiBmb3IgQW5ndWxhci5cbiAqXG4gKiBVc2UgdGhpcyBpbnRlZ3JhdGlvbiBpbiBjb21iaW5hdGlvbiB3aXRoIGBUcmFjZVNlcnZpY2VgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBicm93c2VyVHJhY2luZ0ludGVncmF0aW9uKFxuICBvcHRpb25zOiBQYXJhbWV0ZXJzPHR5cGVvZiBvcmlnaW5hbEJyb3dzZXJUcmFjaW5nSW50ZWdyYXRpb24+WzBdID0ge30sXG4pOiBJbnRlZ3JhdGlvbiB7XG4gIC8vIElmIHRoZSB1c2VyIG9wdHMgb3V0IHRvIHNldCB0aGlzIHVwLCB3ZSBqdXN0IGRvbid0IGluaXRpYWxpemUgdGhpcy5cbiAgLy8gVGhhdCB3YXksIHRoZSBUcmFjZVNlcnZpY2Ugd2lsbCBub3QgYWN0dWFsbHkgZG8gYW55dGhpbmcsIGZ1bmN0aW9uYWxseSBkaXNhYmxpbmcgdGhpcy5cbiAgaWYgKG9wdGlvbnMuaW5zdHJ1bWVudE5hdmlnYXRpb24gIT09IGZhbHNlKSB7XG4gICAgaW5zdHJ1bWVudGF0aW9uSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG9yaWdpbmFsQnJvd3NlclRyYWNpbmdJbnRlZ3JhdGlvbih7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBpbnN0cnVtZW50TmF2aWdhdGlvbjogZmFsc2UsXG4gIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXh0cmFjdGVkIHRvIG1ha2UgdW5pdCB0ZXN0aW5nIGVhc2llci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF91cGRhdGVTcGFuQXR0cmlidXRlc0ZvclBhcmFtZXRyaXplZFVybChyb3V0ZTogc3RyaW5nLCBzcGFuPzogU3Bhbik6IHZvaWQge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gKHNwYW4gJiYgc3BhblRvSlNPTihzcGFuKS5kYXRhKSB8fCB7fTtcblxuICBpZiAoc3BhbiAmJiBhdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA9PT0gJ3VybCcpIHtcbiAgICBzcGFuLnVwZGF0ZU5hbWUocm91dGUpO1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFLCAncm91dGUnKTtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZShTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTiwgYGF1dG8uJHtzcGFuVG9KU09OKHNwYW4pLm9wfS5hbmd1bGFyYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbmd1bGFyJ3MgU2VydmljZSByZXNwb25zaWJsZSBmb3IgaG9va2luZyBpbnRvIEFuZ3VsYXIgUm91dGVyIGFuZCB0cmFja2luZyBjdXJyZW50IG5hdmlnYXRpb24gcHJvY2Vzcy5cbiAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24gZm9yIGV2ZXJ5IHJvdXRlIGNoYW5nZSBhbmQgbWVhc3VyZXMgYSBkdXJhdGlvbiBvZiByb3V0aW5nIHByb2Nlc3MuXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgVHJhY2VTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHVibGljIG5hdlN0YXJ0JDogT2JzZXJ2YWJsZTxFdmVudD4gPSB0aGlzLl9yb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgZmlsdGVyKChldmVudCk6IGV2ZW50IGlzIE5hdmlnYXRpb25TdGFydCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25TdGFydCksXG4gICAgdGFwKG5hdmlnYXRpb25FdmVudCA9PiB7XG4gICAgICBpZiAoIWluc3RydW1lbnRhdGlvbkluaXRpYWxpemVkKSB7XG4gICAgICAgIElTX0RFQlVHX0JVSUxEICYmXG4gICAgICAgICAgZGVidWcuZXJyb3IoJ0FuZ3VsYXIgaW50ZWdyYXRpb24gaGFzIHRyYWNpbmcgZW5hYmxlZCwgYnV0IFRyYWNpbmcgaW50ZWdyYXRpb24gaXMgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcm91dGluZ1NwYW4pIHtcbiAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4uZW5kKCk7XG4gICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gICAgICBjb25zdCBzdHJpcHBlZFVybCA9IHN0cmlwVXJsUXVlcnlBbmRGcmFnbWVudChuYXZpZ2F0aW9uRXZlbnQudXJsKTtcblxuICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAvLyBzZWUgY29tbWVudCBpbiBgX2lzUGFnZWxvYWRPbmdvaW5nYCBmb3IgcmF0aW9uYWxlXG4gICAgICAgIGlmICghdGhpcy5faXNQYWdlbG9hZE9uZ29pbmcoKSkge1xuICAgICAgICAgIHJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHN0YXJ0QnJvd3NlclRyYWNpbmdOYXZpZ2F0aW9uU3BhbihjbGllbnQsIHtcbiAgICAgICAgICAgICAgbmFtZTogc3RyaXBwZWRVcmwsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by5uYXZpZ2F0aW9uLmFuZ3VsYXInLFxuICAgICAgICAgICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06ICd1cmwnLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgZW5kIHVwIGhlcmUsIHdlIHNldCB0aGUgcGFnZWxvYWQgZmxhZyB0byBmYWxzZVxuICAgICAgICAgIC8vIFN1YnNlcXVlbnQgbmF2aWdhdGlvbnMgYXJlIGdvaW5nIHRvIGdldCB0aGVpciBvd24gbmF2aWdhdGlvbiByb290IHNwYW5cbiAgICAgICAgICAvLyBldmVuIGlmIHRoZSBwYWdlbG9hZCByb290IHNwYW4gaXMgc3RpbGwgb25nb2luZy5cbiAgICAgICAgICB0aGlzLl9wYWdlbG9hZE9uZ29pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuID1cbiAgICAgICAgICBydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxuICAgICAgICAgICAgc3RhcnRJbmFjdGl2ZVNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBgJHtuYXZpZ2F0aW9uRXZlbnQudXJsfWAsXG4gICAgICAgICAgICAgIG9wOiBBTkdVTEFSX1JPVVRJTkdfT1AsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by51aS5hbmd1bGFyJyxcbiAgICAgICAgICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdOiAndXJsJyxcbiAgICAgICAgICAgICAgICB1cmw6IHN0cmlwcGVkVXJsLFxuICAgICAgICAgICAgICAgIC4uLihuYXZpZ2F0aW9uRXZlbnQubmF2aWdhdGlvblRyaWdnZXIgJiYge1xuICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvblRyaWdnZXI6IG5hdmlnYXRpb25FdmVudC5uYXZpZ2F0aW9uVHJpZ2dlcixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICkgfHwgbnVsbDtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSksXG4gICk7XG5cbiAgLy8gVGhlIFJlc29sdmVFbmQgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgQW5ndWxhciByb3V0ZXIgaGFzIHJlc29sdmVkIHRoZSBVUkwgYW5kXG4gIC8vIHRoZSBwYXJhbWV0ZXI8LT52YWx1ZSBtYXBwaW5nLiBJdCBob2xkcyB0aGUgbmV3IHJlc29sdmVkIHJvdXRlciBzdGF0ZSB3aXRoXG4gIC8vIHRoZSBtYXBwaW5nIGFuZCB0aGUgbmV3IFVSTC5cbiAgLy8gT25seSBBZnRlciB0aGlzIGV2ZW50LCB0aGUgcm91dGUgaXMgYWN0aXZhdGVkLCBtZWFuaW5nIHRoYXQgdGhlIHRyYW5zYWN0aW9uXG4gIC8vIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIHBhcmFtZXRlcml6ZWQgcm91dGUgbmFtZSBiZWZvcmUgZS5nLiB0aGUgcm91dGUncyByb290XG4gIC8vIGNvbXBvbmVudCBpcyBpbml0aWFsaXplZC4gVGhpcyBzaG91bGQgYmUgZWFybHkgZW5vdWdoIGJlZm9yZSBvdXRnb2luZyByZXF1ZXN0c1xuICAvLyBhcmUgbWFkZSBmcm9tIHRoZSBuZXcgcm91dGUsIHdpdGggdGhlIGV4Y2VwdGlvbnMgb2YgcmVxdWVzdHMgYmVpbmcgbWFkZSBkdXJpbmdcbiAgLy8gYSBuYXZpZ2F0aW9uLlxuICBwdWJsaWMgcmVzRW5kJDogT2JzZXJ2YWJsZTxFdmVudD4gPSB0aGlzLl9yb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgZmlsdGVyKChldmVudCk6IGV2ZW50IGlzIFJlc29sdmVFbmQgPT4gZXZlbnQgaW5zdGFuY2VvZiBSZXNvbHZlRW5kKSxcbiAgICB0YXAoZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgcm91dGUgPSBnZXRQYXJhbWV0ZXJpemVkUm91dGVGcm9tU25hcHNob3QoXG4gICAgICAgIChldmVudC5zdGF0ZSBhcyB1bmtub3duIGFzIFJvdXRlclN0YXRlICYgeyByb290OiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IH0pLnJvb3QsXG4gICAgICApO1xuXG4gICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgZ2V0Q3VycmVudFNjb3BlKCkuc2V0VHJhbnNhY3Rpb25OYW1lKHJvdXRlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0aXZlU3BhbiA9IGdldEFjdGl2ZVNwYW4oKTtcbiAgICAgIGNvbnN0IHJvb3RTcGFuID0gYWN0aXZlU3BhbiAmJiBnZXRSb290U3BhbihhY3RpdmVTcGFuKTtcblxuICAgICAgX3VwZGF0ZVNwYW5BdHRyaWJ1dGVzRm9yUGFyYW1ldHJpemVkVXJsKHJvdXRlLCByb290U3Bhbik7XG4gICAgfSksXG4gICk7XG5cbiAgcHVibGljIG5hdkVuZCQ6IE9ic2VydmFibGU8RXZlbnQ+ID0gdGhpcy5fcm91dGVyLmV2ZW50cy5waXBlKFxuICAgIGZpbHRlcihcbiAgICAgIGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCB8fCBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25DYW5jZWwgfHwgZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRXJyb3IsXG4gICAgKSxcbiAgICB0YXAoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3JvdXRpbmdTcGFuKSB7XG4gICAgICAgIHJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuIS5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KSxcbiAgKTtcblxuICBwcml2YXRlIF9yb3V0aW5nU3BhbjogU3BhbiB8IG51bGw7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIEBzZWUgX2lzUGFnZWxvYWRPbmdvaW5nKClcbiAgICovXG4gIHByaXZhdGUgX3BhZ2Vsb2FkT25nb2luZzogYm9vbGVhbjtcblxuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBfcm91dGVyOiBSb3V0ZXIpIHtcbiAgICB0aGlzLl9yb3V0aW5nU3BhbiA9IG51bGw7XG4gICAgdGhpcy5fcGFnZWxvYWRPbmdvaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQodGhpcy5uYXZTdGFydCQuc3Vic2NyaWJlKCkpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQodGhpcy5yZXNFbmQkLnN1YnNjcmliZSgpKTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHRoaXMubmF2RW5kJC5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB1c2VkIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIHdoZW4gdGhlIHJvb3QgdmlldyBpcyBjcmVhdGVkIGFuZCBkZXN0cm95ZWQgbXVsdGlwbGUgdGltZXMsXG4gICAqIHNpbmNlIGBzdWJzY3JpYmVgIGNhbGxiYWNrcyBjYXB0dXJlIGB0aGlzYCBhbmQgcHJldmVudCBtYW55IHJlc291cmNlcyBmcm9tIGJlaW5nIEdDJ2QuXG4gICAqL1xuICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogV2Ugb25seSBfYXZvaWRfIGNyZWF0aW5nIGEgbmF2aWdhdGlvbiByb290IHNwYW4gaW4gb25lIGNhc2U6XG4gICAqXG4gICAqIFRoZXJlIGlzIGFuIG9uZ29pbmcgcGFnZWxvYWQgc3BhbiBBTkQgdGhlIHJvdXRlciBkaWRuJ3QgeWV0IGVtaXQgdGhlIGZpcnN0IG5hdmlnYXRpb24gc3RhcnQgZXZlbnRcbiAgICpcbiAgICogVGhlIGZpcnN0IG5hdmlnYXRpb24gc3RhcnQgZXZlbnQgd2lsbCBjcmVhdGUgdGhlIGNoaWxkIHJvdXRpbmcgc3BhblxuICAgKiBhbmQgdXBkYXRlIHRoZSBwYWdlbG9hZCByb290IHNwYW4gbmFtZSBvbiBSZXNvbHZlRW5kLlxuICAgKlxuICAgKiBUaGVyZSdzIGFuIGVkZ2UgY2FzZSB3ZSBuZWVkIHRvIGF2b2lkIGhlcmU6IElmIHRoZSByb3V0ZXIgZmlyZXMgdGhlIGZpcnN0IG5hdmlnYXRpb24gc3RhcnQgZXZlbnRcbiAgICogX2FmdGVyXyB0aGUgcGFnZWxvYWQgcm9vdCBzcGFuIGZpbmlzaGVkLiBUaGlzIGlzIHdoeSB3ZSBjaGVjayBmb3IgdGhlIHBhZ2Vsb2FkIHJvb3Qgc3Bhbi5cbiAgICogUG9zc2libGUgcmVhbC13b3JsZCBzY2VuYXJpbzogQW5ndWxhciBhcHBsaWNhdGlvbiBhbmQvb3Igcm91dGVyIGlzIGJvb3RzdHJhcHBlZCBhZnRlciB0aGUgcGFnZWxvYWRcbiAgICogaWRsZSByb290IHNwYW4gZmluaXNoZWRcbiAgICpcbiAgICogVGhlIG92ZXJhbGwgcmF0aW9uYWxlIGlzOlxuICAgKiAtIGlmIHdlIGFscmVhZHkgYXZvaWRlZCBjcmVhdGluZyBhIG5hdmlnYXRpb24gcm9vdCBzcGFuIG9uY2UsIHdlIGRvbid0IGF2b2lkIGl0IGFnYWluXG4gICAqICAgKGkuZS4gc2V0IGBfcGFnZWxvYWRPbmdvaW5nYCB0byBgZmFsc2VgKVxuICAgKiAtIGlmIGBfcGFnZWxvYWRPbmdvaW5nYCBpcyBhbHJlYWR5IGBmYWxzZWAsIGNyZWF0ZSBhIG5hdmlnYXRpb24gcm9vdCBzcGFuXG4gICAqIC0gaWYgdGhlcmUncyBubyBhY3RpdmUvcGFnZWxvYWQgcm9vdCBzcGFuLCBjcmVhdGUgYSBuYXZpZ2F0aW9uIHJvb3Qgc3BhblxuICAgKiAtIG9ubHkgaWYgdGhlcmUncyBhbiBvbmdvaW5nIHBhZ2Vsb2FkIHJvb3Qgc3BhbiBBTkQgYF9wYWdlbG9hZE9uZ29pbmdgIGlzIHN0aWxsIGB0cnVlLFxuICAgKiAgIGRvbid0IGNyZWF0ZSBhIG5hdmlnYXRpb24gcm9vdCBzcGFuXG4gICAqL1xuICBwcml2YXRlIF9pc1BhZ2Vsb2FkT25nb2luZygpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuX3BhZ2Vsb2FkT25nb2luZykge1xuICAgICAgLy8gcGFnZWxvYWQgaXMgYWxyZWFkeSBmaW5pc2hlZCwgbm8gbmVlZCB0byB1cGRhdGVcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVTcGFuID0gZ2V0QWN0aXZlU3BhbigpO1xuICAgIGlmICghYWN0aXZlU3Bhbikge1xuICAgICAgdGhpcy5fcGFnZWxvYWRPbmdvaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdFNwYW4gPSBnZXRSb290U3BhbihhY3RpdmVTcGFuKTtcblxuICAgIHRoaXMuX3BhZ2Vsb2FkT25nb2luZyA9IHNwYW5Ub0pTT04ocm9vdFNwYW4pLm9wID09PSAncGFnZWxvYWQnO1xuICAgIHJldHVybiB0aGlzLl9wYWdlbG9hZE9uZ29pbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgaW5pdGlhbGl6YXRpb24gbGlmZWN5Y2xlIG9mIHRoZSBjb21wb25lbnQgdGhpcyBkaXJlY3RpdmUgaXMgYXBwbGllZCB0by5cbiAqIFNwZWNpZmljYWxseSwgdGhpcyBkaXJlY3RpdmUgbWVhc3VyZXMgdGhlIHRpbWUgYmV0d2VlbiBgbmdPbkluaXRgIGFuZCBgbmdBZnRlclZpZXdJbml0YFxuICogb2YgdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBGYWxscyBiYWNrIHRvIHRoZSBjb21wb25lbnQncyBzZWxlY3RvciBpZiBubyBuYW1lIGlzIHByb3ZpZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiA8YXBwLW15LWNvbXBvbmVudCB0cmFjZT1cIm15Q29tcG9uZW50XCI+PC9hcHAtbXktY29tcG9uZW50PlxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1t0cmFjZV0nIH0pXG5leHBvcnQgY2xhc3MgVHJhY2VEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xuICBASW5wdXQoJ3RyYWNlJykgcHVibGljIGNvbXBvbmVudE5hbWU/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBfdHJhY2luZ1NwYW4/OiBTcGFuO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IF9ob3N0OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50Pikge31cblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgT25Jbml0IGxpZmVjeWNsZSBtZXRob2RcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY29tcG9uZW50TmFtZSkge1xuICAgICAgLy8gVGVjaG5pY2FsbHksIHRoZSBgdHJhY2VgIGJpbmRpbmcgc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZC5cbiAgICAgIC8vIEhvd2V2ZXIsIGlmIGl0IGlzIGluY29ycmVjdGx5IGRlY2xhcmVkIG9uIHRoZSBlbGVtZW50IHdpdGhvdXQgYVxuICAgICAgLy8gdmFsdWUgKGUuZy4sIGA8YXBwLWNvbXBvbmVudCB0cmFjZSAvPmApLCB3ZSBmYWxsIGJhY2sgdG8gdXNpbmcgYHRhZ05hbWVgXG4gICAgICAvLyAod2hpY2ggaXMgZS5nLiBgQVBQLUNPTVBPTkVOVGApLlxuICAgICAgdGhpcy5jb21wb25lbnROYW1lID0gdGhpcy5faG9zdC5uYXRpdmVFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0QWN0aXZlU3BhbigpKSB7XG4gICAgICB0aGlzLl90cmFjaW5nU3BhbiA9IHJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgIHN0YXJ0SW5hY3RpdmVTcGFuKHtcbiAgICAgICAgICBuYW1lOiBgPCR7dGhpcy5jb21wb25lbnROYW1lfT5gLFxuICAgICAgICAgIG9wOiBBTkdVTEFSX0lOSVRfT1AsXG4gICAgICAgICAgYXR0cmlidXRlczogeyBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by51aS5hbmd1bGFyLnRyYWNlX2RpcmVjdGl2ZScgfSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBBZnRlclZpZXdJbml0IGxpZmVjeWNsZSBtZXRob2RcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgY29uc3Qgc3BhbiA9IHRoaXMuX3RyYWNpbmdTcGFuO1xuICAgIGlmIChzcGFuKSB7XG4gICAgICBydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBzcGFuLmVuZCgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIG1vZHVsZSBzZXJ2ZXMgYXMgYSBzaW5nbGUgY29tcGlsYXRpb24gdW5pdCBmb3IgdGhlIGBUcmFjZURpcmVjdGl2ZWAgYW5kIGNhbiBiZSByZS11c2VkIGJ5IGFueSBvdGhlciBtb2R1bGUuXG4gKi9cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW1RyYWNlRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW1RyYWNlRGlyZWN0aXZlXSxcbn0pXG5leHBvcnQgY2xhc3MgVHJhY2VNb2R1bGUge31cblxuaW50ZXJmYWNlIFRyYWNlQ2xhc3NPcHRpb25zIHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGNsYXNzXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIERlY29yYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhcHR1cmUgaW5pdGlhbGl6YXRpb24gbGlmZWN5Y2xlIG9mIHRoZSB3aG9sZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBUcmFjZUNsYXNzKG9wdGlvbnM/OiBUcmFjZUNsYXNzT3B0aW9ucyk6IENsYXNzRGVjb3JhdG9yIHtcbiAgbGV0IHRyYWNpbmdTcGFuOiBTcGFuO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAqL1xuICByZXR1cm4gdGFyZ2V0ID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbE9uSW5pdCA9IHRhcmdldC5wcm90b3R5cGUubmdPbkluaXQ7XG4gICAgdGFyZ2V0LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICguLi5hcmdzOiB1bmtub3duW10pOiBSZXR1cm5UeXBlPHR5cGVvZiBvcmlnaW5hbE9uSW5pdD4ge1xuICAgICAgdHJhY2luZ1NwYW4gPSBydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxuICAgICAgICBzdGFydEluYWN0aXZlU3Bhbih7XG4gICAgICAgICAgb25seUlmUGFyZW50OiB0cnVlLFxuICAgICAgICAgIG5hbWU6IGA8JHtvcHRpb25zPy5uYW1lIHx8ICd1bm5hbWVkJ30+YCxcbiAgICAgICAgICBvcDogQU5HVUxBUl9JTklUX09QLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLnVpLmFuZ3VsYXIudHJhY2VfY2xhc3NfZGVjb3JhdG9yJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICAgIGlmIChvcmlnaW5hbE9uSW5pdCkge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxPbkluaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9yaWdpbmFsQWZ0ZXJWaWV3SW5pdCA9IHRhcmdldC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0O1xuICAgIHRhcmdldC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKC4uLmFyZ3M6IHVua25vd25bXSk6IFJldHVyblR5cGU8dHlwZW9mIG9yaWdpbmFsQWZ0ZXJWaWV3SW5pdD4ge1xuICAgICAgaWYgKHRyYWNpbmdTcGFuKSB7XG4gICAgICAgIHJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRyYWNpbmdTcGFuLmVuZCgpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmlnaW5hbEFmdGVyVmlld0luaXQpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsQWZ0ZXJWaWV3SW5pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAqL1xufVxuXG5pbnRlcmZhY2UgVHJhY2VNZXRob2RPcHRpb25zIHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIG1ldGhvZCAoaXMgYWRkZWQgdG8gdGhlIHRyYWNpbmcgc3BhbilcbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FwdHVyZSBhIHNpbmdsZSBsaWZlY3ljbGUgbWV0aG9kcyBvZiB0aGUgY29tcG9uZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gVHJhY2VNZXRob2Qob3B0aW9ucz86IFRyYWNlTWV0aG9kT3B0aW9ucyk6IE1ldGhvZERlY29yYXRvciB7XG4gIHJldHVybiAoX3RhcmdldDogdW5rbm93biwgcHJvcGVydHlLZXk6IHN0cmluZyB8IHN5bWJvbCwgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoLi4uYXJnczogdW5rbm93bltdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxNZXRob2Q+IHtcbiAgICAgIGNvbnN0IG5vdyA9IHRpbWVzdGFtcEluU2Vjb25kcygpO1xuXG4gICAgICBydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgIHN0YXJ0SW5hY3RpdmVTcGFuKHtcbiAgICAgICAgICBvbmx5SWZQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgbmFtZTogYDwke29wdGlvbnM/Lm5hbWUgPyBvcHRpb25zLm5hbWUgOiAndW5uYW1lZCd9PmAsXG4gICAgICAgICAgb3A6IGAke0FOR1VMQVJfT1B9LiR7U3RyaW5nKHByb3BlcnR5S2V5KX1gLFxuICAgICAgICAgIHN0YXJ0VGltZTogbm93LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLnVpLmFuZ3VsYXIudHJhY2VfbWV0aG9kX2RlY29yYXRvcicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSkuZW5kKG5vdyk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG9yaWdpbmFsTWV0aG9kKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH07XG59XG5cbi8qKlxuICogVGFrZXMgdGhlIHBhcmFtZXRlcml6ZWQgcm91dGUgZnJvbSBhIGdpdmVuIEFjdGl2YXRlZFJvdXRlU25hcHNob3QgYW5kIGNvbmNhdGVuYXRlcyB0aGUgc25hcHNob3Qnc1xuICogY2hpbGQgcm91dGUgd2l0aCBpdHMgcGFyZW50IHRvIHByb2R1Y2UgdGhlIGNvbXBsZXRlIHBhcmFtZXRlcml6ZWQgVVJMIG9mIHRoZSBhY3RpdmF0ZWQgcm91dGUuXG4gKiBUaGlzIGhhcHBlbnMgcmVjdXJzaXZlbHkgdW50aWwgdGhlIGxhc3QgY2hpbGQgKGkuZS4gdGhlIGVuZCBvZiB0aGUgVVJMKSBpcyByZWFjaGVkLlxuICpcbiAqIEBwYXJhbSByb3V0ZSB0aGUgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCBvZiB3aGljaCBpdHMgcGF0aCBhbmQgaXRzIGNoaWxkJ3MgcGF0aCBpcyBjb25jYXRlbmF0ZWRcbiAqXG4gKiBAcmV0dXJucyB0aGUgY29uY2F0ZW5hdGVkIHBhcmFtZXRlcml6ZWQgcm91dGUgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJpemVkUm91dGVGcm9tU25hcHNob3Qocm91dGU/OiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IHwgbnVsbCk6IHN0cmluZyB7XG4gIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGxldCBjdXJyZW50Um91dGUgPSByb3V0ZT8uZmlyc3RDaGlsZDtcbiAgd2hpbGUgKGN1cnJlbnRSb3V0ZSkge1xuICAgIGNvbnN0IHBhdGggPSBjdXJyZW50Um91dGU/LnJvdXRlQ29uZmlnICYmIGN1cnJlbnRSb3V0ZS5yb3V0ZUNvbmZpZy5wYXRoO1xuICAgIGlmIChwYXRoID09PSBudWxsIHx8IHBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChwYXRoKTtcbiAgICBjdXJyZW50Um91dGUgPSBjdXJyZW50Um91dGUuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIGNvbnN0IGZ1bGxQYXRoID0gcGFydHMuZmlsdGVyKHBhcnQgPT4gcGFydCkuam9pbignLycpO1xuICByZXR1cm4gZnVsbFBhdGggPyBgLyR7ZnVsbFBhdGh9L2AgOiAnLyc7XG59XG4iXX0=